//
//  NCNode.m
//  cocoaNEC
//
//  Created by Kok Chen on 9/17/07.
//	-----------------------------------------------------------------------------
//  Copyright 2007-2016 Kok Chen, W7AY. 
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//		http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.
//	-----------------------------------------------------------------------------

#import "NCNode.h"


//  An NCNode is a node of the DAG that is generated by the parser.
//	When an -execute: message is passed to an NCNode, it generates an NCValue.
//	Each NCNode is associated with a left NCode and a right NCNode.  The 
//	right node is possibly nil.

@implementation NCNode

//	v0.76: include enclosing function for all NCNodes, to allow stack frames to be saves on function calls
- (id)initWithParser:(NCParser*)inParser symbols:(NCSymbolTable*)symbolList enclosingFunction:(NCFunction*)fn iterateLevel:(int)level
{
	self = [ super init ] ;
	if ( self ) {
		symbols = symbolList ;
		parser = inParser ;
		enclosingFunction = fn ;			//  v0.76
		lvalue = NO ;
		token = [ parser token ] ;
		line = type = op = 0 ;
		left = right = nil ;
		stack = nil ;
		iterateLevel = level ;
		nodeType = "NCNode" ;
	}
	return self ;
}

- (id)clone:(NCNode*)clone
{
	self = [ super init ] ;
	if ( self ) {
		symbols = [ clone symbols ] ;
		parser = [ clone parser ] ;
		lvalue = [ clone lvalue ] ;
		line = [ clone line ] ;
		type = [ clone type ] ;
		left = [ clone left ] ;
		right = [ clone right ] ;
		op = [ clone op ] ;
		stack = [ clone stack ] ;
		iterateLevel = [ clone iterateLevel ] ;
		nodeType = "cloned NCNode" ;
	}
	return self ;
}

- (void)dealloc
{
	if ( left ) [ left release ] ;
	if ( right ) [ right release ] ;
	[ super dealloc ] ;
}

- (Boolean)parse
{
	printf( "need to implement -parse in subclass %s\n", [ [ self description ] UTF8String ] ) ;
	return NO ;
}
		
- (NCValue*)execute:(RuntimeStack*)stack asReference:(Boolean)asReference
{
	printf( "need to implement -execute in subclass %s\n", [ [ self description ] UTF8String ] ) ;
	return nil ;
}

//	v0.52 - used by NCFunction to init local vaiables that are arguments
- (NCValue*)execute:(RuntimeStack*)stack initArguments:(NSArray*)args
{
	printf( "need to implement -execute:initArguments in subclass %s\n", [ [ self description ] UTF8String ] ) ;
	return nil ;
}

- (Boolean)lvalue
{
	return lvalue ;
}

- (int)type
{
	return type ;
}

- (NSString*)symbolName
{
	return @"unknown" ;
}

- (const char*)nodeType
{
	return nodeType ;
}

- (NCObject*)ncObject
{
	if ( left ) return [ left ncObject ] ;
	return nil ;
}

- (int)typeForBinaryOp:(NCNode*)inLeft right:(NCNode*)inRight
{
	int leftType = [ inLeft type ] ;
	
	switch ( leftType ) {
	case INTTYPE:
	case REALTYPE:
		if ( [ inRight type ] == REALTYPE ) return REALTYPE ;
		return leftType ;
	case VECTORTYPE:
		if ( ( op == PLUS || op == MINUS ) && [ inRight type ] == VECTORTYPE ) return VECTORTYPE ;
		return 0 ;
	default:
		return 0 ;
	}
}

//  for cloning
- (NCSymbolTable*)symbols
{
	return symbols ;
}

- (NCParser*)parser
{
	return parser ;
}

- (NCNode*)left 
{
	return left ;
}

- (NCNode*)right
{
	return right ;
}

- (int)op 
{
	return op ;
}

- (int)line 
{
	return line ;
}

- (RuntimeStack*)stack
{
	return stack ;
}

- (int)iterateLevel 
{
	return iterateLevel ;
}

// log a runtime error
- (void)runtimeMessage:(NSString*)err
{
	[ stack->errors addObject:[ NSString stringWithFormat:@"%s (line %d)", [ err UTF8String ], line ] ] ;
}

@end
